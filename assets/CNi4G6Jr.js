import ye from"./CbqMunXl.js";import xe from"./DAKP5pNJ.js";import{r as y,cc as W,d as we,u as be,P as Se,e0 as ke,ca as Te,cC as Ae,f as _e,b as A,w as N,p as M,V as q,q as K,a as G,c as Ne,cF as Ie,c8 as Ve,cx as Oe,o as H,_ as Ee}from"./_BmmGIGi.js";import{x as Be,p as D,a as j,y as Ce}from"./BMM55Xfq.js";import{u as Pe}from"./MPRDzB1v.js";import{b as $}from"./D5-R3KnC.js";import{V as Me}from"./C7URMWzZ.js";import{V as Je}from"./Cx6b7hxJ.js";const Q=b=>{const k={};return b==null||b.forEach(S=>{const{key:E,type:v,isArray:x}=S;let u;switch(v){case"number":u="";break;case"text":u="";break;case"select":u=S.defaultValue;break;case"checkbox":u=!1;break;default:u=""}x&&(u=[u]),k[E]=u}),k};function Le(){const b=y(!1),k=y("");return{loading:b,error:k,fetchTransactions:async(v,x,u,T)=>{if(!x)throw new Error("missing-address");if(u==null)throw new Error("missing-block");const{$getExplorer:V}=W();let _;try{_=V(v)}catch{return[]}k.value="",b.value=!0;try{return await _.fetchWalletTransactions(x,u,T)}catch(g){throw k.value=g.message||"Failed to fetch transactions",g}finally{b.value=!1}},fetchTokenTransfers:async(v,x,u,T)=>{if(!x)throw new Error("missing-address");if(u==null)throw new Error("missing-block");const{$getExplorer:V}=W();let _;try{_=V(v)}catch{return[]}k.value="",b.value=!0;try{return await _.fetchWalletTokenTransfers(x,u,T)}catch(g){throw k.value=g.message||"Failed to fetch token transfers",g}finally{b.value=!1}}}}const Fe={class:"delegated-permission"},Re={class:"input-group"},Ue={class:"progress-text"},De=we({__name:"DelegatedPermissions",props:{modelValue:{},chainId:{},safeAddress:{},title:{},fieldsMap:{},submitLabel:{},isLoading:{type:Boolean},tooltipTitle:{},tooltipLink:{},alwaysShowLastStep:{type:Boolean}},emits:["update:modelValue","fieldsChanged","submit","cancel","addRaw","entryUpdated"],setup(b,{emit:k}){const S=b,E=k,v=y(JSON.parse(JSON.stringify(S.modelValue))),x=y(!1),u=y(""),T=y(!0),V=y(!1),_=y([]),g=y(""),J=y(""),L=y(""),B=y(!1),C=y(0),F=be(),O=Pe(),X=Se(),R=new ke,Y={idx:0,value:[{idx:0,isArray:!1,data:"1",internalType:"uint16",name:"role"},{idx:1,isArray:!1,data:"",internalType:"address",name:"targetAddress"}],valueMethodIdx:24},Z={idx:0,value:[{idx:0,isArray:!1,data:1,internalType:"uint16",name:"role"},{idx:1,isArray:!1,data:"",internalType:"address",name:"targetAddress"},{idx:2,isArray:!1,data:"",internalType:"bytes4",name:"functionSig"},{idx:3,isArray:!1,data:1,internalType:"enum ExecutionOptions",name:"options"}],valueMethodIdx:18},P={idx:0,value:[{idx:0,isArray:!1,data:"1",internalType:"uint16",name:"role"},{idx:1,isArray:!1,data:"",internalType:"address",name:"targetAddress"},{idx:2,isArray:!1,data:"",internalType:"bytes4",name:"functionSig"},{idx:3,isArray:!1,data:"",internalType:"uint256",name:"paramIndex"},{idx:4,isArray:!1,data:"0",internalType:"enum ParameterType",name:"paramType"},{idx:5,isArray:!1,data:"0",internalType:"enum Comparison",name:"paramComp"},{idx:6,isArray:!1,data:"",internalType:"bytes",name:"compValue"}],valueMethodIdx:21},U={idx:0,value:[{idx:0,isArray:!1,data:"1",internalType:"uint16",name:"role"},{idx:1,isArray:!1,data:"",internalType:"address",name:"targetAddress"},{idx:2,isArray:!1,data:"",internalType:"bytes4",name:"functionSig"},{idx:3,isArray:!1,data:"",internalType:"uint256",name:"paramIndex"},{idx:4,isArray:!1,data:"",internalType:"enum ParameterType",name:"paramType"},{idx:5,isArray:!0,data:[],internalType:"bytes[]",name:"compValues"}],valueMethodIdx:22},ee=t=>{if(!t.every(a=>Number.isInteger(a)&&a>=0))throw new Error("Invalid block numbers: must be non-negative integers");return t.map(a=>({jsonrpc:"2.0",method:"eth_getBlockByNumber",params:[R.utils.toHex(a),!0],id:a}))},ae=t=>{const a=ee(t);return X.callWithRetry(S.chainId,()=>{const r=new R.eth.BatchRequest,o=a.map(e=>new Promise((l,s)=>{r.add({jsonrpc:"2.0",method:e.method,params:e.params,id:e.id}).then(d=>{l(d)})}));return r.execute(),Promise.all(o)},8,[],1e3)},te=(t,a)=>{const r=[];console.log("BLOCKS ",a);for(const o of a)if(o.transactions)for(const e of o.transactions)e.from&&e.from.toLowerCase()===t.toLowerCase()&&(console.log("tx",e),r.push({blockNumber:parseInt(e.blockNumber,16),hash:e.hash,from:e.from,to:e.to||"",input:e.input,timestamp:0,value:e.value,gasUsed:"0",gasPrice:"0"}));return r},{fetchTransactions:se}=Le(),oe=async(t,a)=>{console.warn("getExplorerTransactions",t,a);const r=a.map(e=>se(S.chainId,t,e.startBlock,e.endBlock)),o=(await Promise.all(r)).flat();return console.warn("getExplorerTransactions transactions",o),o},re=async(t,a)=>{const o=[],e=a.reduce((s,p)=>s+(p.endBlock-p.startBlock+1),0);let l=0;for(const s of a){const p=Array.from({length:s.endBlock-s.startBlock+1},(d,h)=>s.startBlock+h);for(let d=0;d<p.length;d+=10){console.log("range start: ",d);const h=p.slice(d,d+10),m=await ae(h),f=te(t,m);o.push(...f),l+=h.length,C.value=e>0?l/e*100:0}}return o},ne=(t,a,r=64)=>{const o="0x095ea7b3";let e=!1;t.slice(0,10)===o&&(e=!0);const l=t.slice(10),s=[];for(let d=0;d<l.length;d+=r)s.push(l.slice(d,d+r));const p=s.map((d,h)=>d.includes(a.slice(2).toLowerCase())?h:-1).filter(d=>d!==-1);return{func_sig:t.slice(0,10),calldata_len_sans_sig:l.length,words:s,indices_of_addr:p,full_calldata:t,contract:"",token_found_idx:[],is_approval:e}},le=t=>new Map(t.map(a=>[a.toLowerCase(),[]])),ie=t=>{const a="0x095ea7b3",r=[];let o=0;for(const[e,l]of t){let s=structuredClone(U);const p=[...new Set(l)];p.length===1?(s=structuredClone(P),s.value[1].data=e,s.value[2].data=a,s.value[3].data="0",s.value[4].data="0",s.value[5].data="0",s.value[6].data=p[0],s.idx=o++):(s.value[1].data=e,s.value[2].data=a,s.value[3].data="0",s.value[4].data="0",s.value[5].data=p,s.idx=o++),r.push(s)}return r},de=(t,a,r)=>{if(!a||!r)return;const o=t.get(a.toLowerCase())||[];t.set(a.toLowerCase(),[...o,"0x"+r])},ce=(t,a,r)=>{const o=[],e=[],l=[];for(const n of t){const w=ne(n.input,r);w.is_approval&&o.push(n.to),e.push(n.to),w.contract=n.to,l.push(w)}const s=[...new Set(o)],p=le(s);for(const n of l)if(n.is_approval)de(p,n.contract,n.words[0]);else{const w=n.words.map((I,i)=>s.some(c=>I.includes(c.slice(2).toLowerCase()))?i:-1).filter(I=>I!==-1);n.token_found_idx=w}const d=[...new Set(e)],h=s.map(n=>"0x000000000000000000000000"+n.slice(2));let m=0;const f=[];for(const n of[...d,...s]){const w=JSON.parse(JSON.stringify(Y));w.value[1].data=n,w.idx=m++,f.push(w)}const ge=ie(p);f.push(...ge.map(n=>({...n,idx:m++})));for(const n of l){const w=n.indices_of_addr.length,I=n.token_found_idx.length;if(w===0&&I===0){const i=JSON.parse(JSON.stringify(Z));i.value[1].data=n.contract,i.value[2].data=n.func_sig,i.idx=m++,f.push(i)}else{if(I!==0)if(I===1)if(s.length===1){const i=JSON.parse(JSON.stringify(P));i.value[1].data=n.contract,i.value[2].data=n.func_sig,i.value[3].data=String(n.token_found_idx[0]),i.value[4].data="0",i.value[5].data="0",i.value[6].data=h[0],i.idx=m++,f.push(i)}else{const i=JSON.parse(JSON.stringify(U));i.value[1].data=n.contract,i.value[2].data=n.func_sig,i.value[3].data=String(n.token_found_idx[0]),i.value[4].data="0",i.value[5].data=h,i.idx=m++,f.push(i)}else for(const i of n.token_found_idx)if(s.length===1){const c=JSON.parse(JSON.stringify(P));c.value[1].data=n.contract,c.value[2].data=n.func_sig,c.value[3].data=String(i),c.value[4].data="0",c.value[5].data="0",c.value[6].data=h[0],c.idx=m++,f.push(c)}else{const c=JSON.parse(JSON.stringify(U));c.value[1].data=n.contract,c.value[2].data=n.func_sig,c.value[3].data=String(i),c.value[4].data="0",c.value[5].data=h,c.idx=m++,f.push(c)}if(w!==0)for(const i of n.indices_of_addr){const c=JSON.parse(JSON.stringify(P));c.value[1].data=n.contract,c.value[2].data=n.func_sig,c.value[3].data=String(i),c.value[4].data="0",c.value[5].data="0",c.value[6].data="0x000000000000000000000000"+a.slice(2),c.idx=m++,f.push(c)}}}return f},ue=async()=>{try{if(B.value=!0,C.value=0,!R.utils.isAddress(g.value))throw new Error("Invalid Ethereum address");const t=J.value.split(",").map(e=>parseInt(e.trim())).filter(e=>!isNaN(e)&&e>=0),a=L.value.split(",").map(e=>parseInt(e.trim())).filter(e=>!isNaN(e)&&e>=0);if(t.length!==a.length||t.length===0)throw new Error("Mismatched or empty block ranges");const r=t.map((e,l)=>({startBlock:e,endBlock:a[l]})).filter(e=>e.startBlock<=e.endBlock);if(r.length===0)throw new Error("No valid block ranges");if(!S.safeAddress)throw new Error(`Bad Custody Address ${S.safeAddress}`);let o=[];try{o=await oe(g.value,r)}catch(e){console.error("Failed fetching explorer transactions -> ",e),o=await re(g.value,r)}_.value=ce(o,S.safeAddress,g.value),u.value=JSON.stringify(_.value),T.value=!1}catch(t){console.error("Error generating permissions:",t),F.errorToast("Failed to generate permissions: "+t.message)}finally{B.value=!1,C.value=0}},pe=()=>x.value=!0,z=()=>{try{const t=JSON.parse(u.value);if(!t)throw new Error("Invalid JSON");console.log("proposal:",t);const a=[];t.forEach(o=>{var d,h;const e=Be.find(m=>m.valueMethodIdx===o.valueMethodIdx);if(!(e!=null&&e.value)){console.error("Contract method not found");return}const l=Q(D[e.value]),s=(h=(d=S.fieldsMap)==null?void 0:d.setup)==null?void 0:h[l.contractMethod];o.value.forEach(m=>{const f=(m==null?void 0:m.name)||"";if(!f){console.error("Value name not found");return}l[f]=(m==null?void 0:m.data)??""}),l.isValid=me(l,s);const p=JSON.parse(JSON.stringify(l));a.push(p)});const r=v.value.findIndex(o=>o.stepName===j.Setup);if(r===-1){console.error("Main step not found");return}T.value?v.value[r].steps.push(...a):v.value[r].steps=a,x.value=!1,u.value="",F.successToast("Raw proposal added successfully")}catch(t){console.error(t),F.errorToast("Failed to add raw proposal. Invalid JSON format.")}},me=(t,a)=>{let r=!0;return a.forEach(o=>{const{key:e,rules:l=[]}=o,s=t[e];l.forEach(p=>{Array.isArray(s)?r=s.every(d=>p(d)===!0):r=p(s)===!0})}),r},fe=()=>E("submit"),ve=()=>{var o;if(!V.value)return;const t=((o=v.value.find(e=>e.stepName===j.Setup))==null?void 0:o.steps)??[],a=v.value.find(e=>e.stepName===j.Details);if(!a)return;const r=[];t.forEach(e=>{const l=D[e.contractMethod].filter(s=>s.key!=="contractMethod").map(s=>Ce({...s,data:e[s.key]}));r.push({funcName:e.contractMethod,args:l}),O.rawTransactions=[...r],a.steps[0].transactionsOverview=JSON.stringify(O.rawTransactions.map(s=>[s.funcName,s.args]),null,2),a.steps[0].transactionsRawJSON=O.rawTransactionsJson})},he=(t,a,r)=>{var d,h,m;ve();const o=Q(D[r.contractMethod]),e=v.value.findIndex(f=>f.stepName===t);if(e===-1){console.error("Main step not found");return}const l=(m=(h=(d=v==null?void 0:v.value)==null?void 0:d[e])==null?void 0:h.steps)==null?void 0:m[a];if(!l){console.error("Substep not found");return}const s=Object.keys(l).filter(f=>f!=="contractMethod"),p=Object.keys(o).every(f=>f in l);Object.hasOwn(l,"isValid")||(l.isValid=!1),!p&&(s.forEach(f=>{delete l[f]}),Object.assign(l,o))};return Te(()=>{O.rawTransactions.length&&(T.value=!1,u.value=O.rawTransactionsJson,console.log("mounted raw",u.value),z(),O.rawTransactions=[]),V.value=!0}),Ae(()=>v.value,t=>{E("entryUpdated",t)},{deep:!0}),(t,a)=>{const r=ye,o=xe;return H(),_e("div",Fe,[A(r,{entry:v.value,"fields-map":t.fieldsMap,title:t.title,"submit-label":t.submitLabel,"submit-event":fe,"is-submit-loading":t.isLoading,"always-show-last-step":t.alwaysShowLastStep,class:"delegated-permission-stepper",onFieldsChanged:he},{title:N(()=>[M(t.$slots,"title",{},void 0,!0)]),"post-steps-content":N(()=>[M(t.$slots,"post-steps-content",{},void 0,!0)]),"pre-content":N(()=>[M(t.$slots,"pre-content",{},void 0,!0)]),subtitle:N(()=>[M(t.$slots,"subtitle",{},void 0,!0),A(q,{class:"text-secondary me-4",variant:"outlined",onClick:pe},{default:N(()=>a[6]||(a[6]=[K(" Import Raw Permissions ")])),_:1})]),_:3},8,["entry","fields-map","title","submit-label","is-submit-loading","always-show-last-step"]),A(o,{modelValue:x.value,"onUpdate:modelValue":a[5]||(a[5]=e=>x.value=e),title:"Import Raw Permissions JSON","max-width":"80%","confirm-text":"Import Raw Permissions","cancel-text":"Cancel",onConfirm:z},{default:N(()=>[A($,{modelValue:g.value,"onUpdate:modelValue":a[0]||(a[0]=e=>g.value=e),label:"Address",outlined:"",placeholder:"Enter Ethereum address",class:"me-4"},null,8,["modelValue"]),A($,{modelValue:J.value,"onUpdate:modelValue":a[1]||(a[1]=e=>J.value=e),label:"Start Blocks (comma-separated)",outlined:"",placeholder:"Enter start blocks (e.g., 1000,2000)",class:"me-4"},null,8,["modelValue"]),A($,{modelValue:L.value,"onUpdate:modelValue":a[2]||(a[2]=e=>L.value=e),label:"End Blocks (comma-separated)",outlined:"",placeholder:"Enter end blocks (e.g., 1500,2500)",class:"me-4"},null,8,["modelValue"]),G("div",Re,[A(q,{class:"text-secondary me-4",variant:"outlined",loading:B.value,disabled:B.value,onClick:ue},{default:N(()=>a[7]||(a[7]=[K(" Generate Permissions From Address History ")])),_:1},8,["loading","disabled"]),B.value?(H(),Ne(Oe,{key:0,value:C.value,size:24,width:3,color:"primary",class:"me-4"},{default:N(()=>[G("span",Ue,Ve(Math.round(C.value))+"%",1)]),_:1},8,["value"])):Ie("",!0)]),A(Me,{modelValue:u.value,"onUpdate:modelValue":a[3]||(a[3]=e=>u.value=e),label:"Raw proposal",outlined:"",placeholder:"Enter the raw permissions JSON here asd",rows:"20",class:"raw-method-textarea"},null,8,["modelValue"]),A(Je,{modelValue:T.value,"onUpdate:modelValue":a[4]||(a[4]=e=>T.value=e),label:"Keep existing permissions",class:"checkbox-keep-existing-permissions"},null,8,["modelValue"])]),_:1},8,["modelValue"])])}}}),Qe=Ee(De,[["__scopeId","data-v-6f84bbf4"]]);export{Qe as _,Q as f};
